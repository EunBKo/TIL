### HTML 파싱

브라우저는 위에서 이야기한 토큰화된 HTML의 문자열들을 이용해 **파스 트리(Parse Tree)**를 생성한다. 

파스 트리는 브라우저가 읽어야 할 HTML 코드를 트리 모양으로 구조화하여 나타낸 것이다.

이러한 파스 트리를 이용해서 렌더를 바로 할 수 있을까? 

그렇지 않다. 

브라우저는 파스 트리를 이용해 **DOM(Document Object Model)** 트리를 새로 만들기 때문이다. 그렇다면 두 트리의 차이점은 무엇일까?

파스 트리는 토큰화된 문자열을 단순하게 구조화한 트리에 불과했지만, DOM 트리는 우리가 실제로 상호작용할 수 있는 HTML 엘리먼트로 이루어진 트리이다. 따라서 우리가 실제로 JavaScript로 상호작용할 수 있는 부분은 DOM 트리이다.

한편, HTML 파서는 다른 파서와 비교했을 때 조금 독특한 특징을 갖고 있다. HTML 파서의 첫 번째 특징은 **오류에 너그러운(forgiving nature) 속성이**다. 

다시 말해, HTML을 파싱하는 도중 어떠한 에러가 발생한다면, 브라우저는 자체적으로 에러를 복구하려 한다. 아래와 같은 HTML 코드를 생각해보자.

```jsx
<body>
<p class=highlight>Hello
<div><span>World
```

위 예제는 제대로 작성되지 않은 HTML 코드를 나타낸다. 

최상단에 `<html>` 태그를 쓰지 않았고, `<body>`, `<p>`, `<div>`, `<span>` 태그 같은 경우에는 닫는 태그를 작성하지 않았다. 

또한 클래스 어트리뷰트를 쌍따옴표로 묶어주지도 않았다. 

하지만 이 HTML 코드를 실제로 브라우저에서 실행시켜보면 다음과 같이 완성된 코드가 나옵니다.

`<body><p class="highlight">Hello</p><div><span>World</span></div></body>`

이러한 규칙들은 HTML Document Type Definition (DTD)에 의해 정의되고 있다. HTML 파서는 명세된 규칙들을 따르는 예외 처리를 따로 해주어야 한다. 그리고 이는 일반적인 파서의 규칙만으로는 적용하기가 어렵다.

> 정확하게는 대부분의 프로그래밍 언어가 촘스키 계층의 문맥 자유 문법(Context-free grammar)에 속하는 것에 반해, HTML은 자체의 특징 때문에 위 계층에 속하지 않기 때문이다.

HTML 파서의 두 번째 특징는 **파싱 과정이 중단될 수 있다는 것이**다. 

HTML은 파싱 도중 `<script>`, `<link>` 같은 외부 태그를 만나게 되면 HTML 파싱을 즉시 중단한다. 그리고 해당 태그의 해석을 실행한다. 

만약 해당 태그가 외부 파일을 참조하고 있다면 다운로드를 한 후 해석을 시작한다.

이는 네트워크를 통해 먼저 받아온 코드부터 해석을 실행할 수 있는 HTML과는 달리 외부 컨텐츠들은 증분적(Incrementally)으로 해석을 할 수 없기 때문이다. 또 다른 이유는 `<script>`에 DOM을 직접 수정할 수 있는 내용이 있을 수도 있기 때문이다. 가령 `document.write()` 같은 API를 사용하면 HTML을 파싱하고 있는 도중에도 DOM 엘리먼트를 동적으로 삽입할 수 있다. 이로 인해 외부 컨텐츠를 해석하고 실행하기까지 HTML의 파싱은 중단된다.

이러한 문제점을 해결하기 위해서 스크립트 같은 경우에는 별도의 옵션을 제공한다.

> 일부 브라우저에서는 예측 파싱(Speculative parsing) 기법을 이용해 별도의 쓰레드에서 외부 스크립트, 링크, 스타일 등을 불러오기도 한다.

HTML 파서의 세 번째 특징은 **재시작(Reentrant)이**다. 위에서 말한 것처럼 HTML의 파싱 과정은 어떠한 외부의 요인으로 인해 방해받을 수 있다. 파싱 중간에 외부의 요인으로 인해 DOM이 추가, 변경, 삭제 될 수 있다.

이러한 경우에 HTML은 처음부터 다시 파싱 과정을 거친다. 즉, 바이트를 문자로 변환하고, 토큰을 식별한 후 노드로 변환하고 DOM 트리를 빌드한다. 이 때문에 처리해야 할 HTML이 많을 때에는 파싱 시간이 오래 걸릴 수 있다.

